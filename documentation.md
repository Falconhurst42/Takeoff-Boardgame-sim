# What the program is meant to do:
> My family owns and enjoys a board game called "Take-off" in which players move a fleet of planes across a map of the world. However, whenever we play we get into an argument about how to play. We each want to impliment slightly more or less punishing rules to make the game a more managable length. My project attempts to put those arguments to rest by simulating many Take-off games (which are themselves a simulation of real planes) under different rule-sets and comparing the results

# What the program will need to do:
> To simulate a game the program will need
> - a `Game` object to store and handle the map (hash table), deck (queue), dice (function), and players (objects) as well and compiling the benchmarking data
> - `Airport` structures to populate the map as spaces, track the connections between spaces, and track the location of planes
> - `Player` objects to store and handle `Airplane` objects as gameplay pieces. On their turn, the `Game` will tell a `Player` which actions they are allowed to take and a player must consider all the possibilites, choose the best one, and send those directions to the planes
> - `Airplane` objects to serve as piece which should handle their movements. `Players` will send Airplanes `Actions` which the Airplane must parse and execute: locating their destination and updating the location-tracking of their current (soon to be former) `Airport`, their destination `Airport`, and their own internal locaion tracking
> - Additional utlity structures such as `Color` and `Action` to hold common groupings of data and/or data designated for a particular role
> 
> A Game will require:
> - Game setup
> - A main gameplay loop
> - Game ending
> 
> Game setup will require:
> - generating all `Players`, `Airplanes`, `Airports`, and connections between `Airports`, as well as initializing the map and deck(s)
> 
> Game ending will involve:
> - Variable cleanup(if necessary)
> - Outputting benchmark data
> 
> The main gameplay loop will involve:
> - Iterating through rounds
> - Iterating through `player's` turns
> - Rolling for `players` and sending them actions to use that turn
> - Keeping track of when `players` or the `game` are finished
> - Collecting benchmark data
> 
> Player's turns will involve
> - Simulating all possible movements with given `actions` and `airplanes`
> - Evaluating which set of movements is the best
> - Executing those movements by sending `actions` to the `airplanes`
> - Handling bumping other `player's` `airplanes`
> - Detecting when one or all of their `airplanes` have finished
> - Collecting benchmark data

# Notable Programming solutions

>There are a few parts of my program that deserve some additional explaination
>
>## __The Map__
> ![](.\IMG_2761.JPG)
> > The Take-off map is essentially a web of Airports connected by colored "routes." Each turn, the player will roll the dice to see which colors they can move on that turn and then move accordingly. You might roll green and a wild and decide to move one of your planes (the pieces) from Heathrow to JFK along a green, and another from Sydney to Dehli on red with the wild. I decided to store my Airport objects in a map, with the connections being stored in vectors of pairs of pointers and colors in each Airport (each airport knows where it's outgoing routes connect to and with what colors, as well as where it's incoming route connect to and with which colors).
> >
> > Currently, the map is generated by pulling Airport data from "map.txt" and automatically generating connections between nearby airport, enforcing continuous east-to-west motion. The map is initialized with the game object and the Airports and connections remain the same for the entire life of that game object
> > 
> > > __DISCLAIMER:__ What follows is a long and probably unconvincing explaination as to why I used a hash table to store my Airports instead of doing it all with a custom web/tree structure. Read it at your own risk
> >
> > > _The game's map is a `hash table` (std::unorderer_map) of Airports keyed with strings stored in the Game object. While the map hash a tree-like structure with its Airport nodes and connection branches, a tree was not used for two reasons, one of which is actually good. My initial reason was "Take-off" card. Players will often roll a "Take-off" action which will jump one of their plane's to a random location on the map (drawn from the deck). In game, this involves searching the map for the Airport on the card, and searching a "tree" where nodes have multiple parents would be a nightmare. Meanwhile, hash tables are designed for direct access via a key: the name on the card. Simply put the names of the airport on the "card" and use that as the hash table key. Admittedly, because this is a program and not real life, I could I have put a point to the airport "on the card" instead of its name, so this wasn't really a problem at all. My second, better although not perfect reason was that a stl hash table is much more reliable than a a custom tree I made. Additionally, I reasoned, the main downside of a hash table is its size, but my map was going to be limited to, at most, about 100 items which is small in the grand computer science scal of things. I decided to use the stable, stl hash table as my base container, with connections stored in both the child and parent Airport_
> 
>
> ## __Player AI__
> > Each turn, players essentially receive a list of possible actions from whatever they rolled. Normally, that's a list of 2, one for each dice, although doubles take that number to 4. Combined with their (by defualt) 4 planes, that is quite a lot of possible turns, especially when one factors in wilds.
> >
> > In my simulation, computer players decide how to use their rolls like so:
> > - First, use any Take-off! actions your rolled and use them on your worst planes. You've gotta use them first by the rules (or at least it's more fun that way), and it's (almost) always best to use your worst plane for it.
> > - Next, get all the possible orders you could use the remaining moves and the ways you could apply them to your planes. (For two moves A and B and two planes 1 and 2, that's AB and BA and 11, 12, 21, and 22).
> > - For each permutation of planes, for each permutation of actions applied to those planes, play out those moves on a "shadow board" and pick the best one
> > - The "best" series of movements must use as many actions as possible and avoid illegal moves. After that, the computer will prioritize advancing their planes and bumping other players.
> > - Finally, do all those actions you decided on for real
>
> ## __Simulations__
> > Every turn, a player will need to consider many possible sequences of movements. The only way to effectively determine which moves are legal and which are best is to simulate what you would happen if you took those actions on those planes. In order to account for all the events possible in a turn, such simulations effectively require a copy of the entire board where the actions can be performed and analyzed without effecting the main gamestate. We will call this the "shadow board". In order to avoid creating a copy of all Aiports and Airplanes every time it wants to simulate a move, the program instead gives each Airport an "occupancy" and a "shadow occupancy" and each Airplane has a "location" and a "shadow location." Before each simulation, the shadow occupancies and locations are synced to their main-board counterparts. To preform a simulation, the program uses all the same movement functions, but it sends each one a flag saying "this is happening on the shadow board." That's how the program simulates turns without effecting the real board or having to copy a bunch of stuff. This is especially important because the simulations are the most time-consuming part of the whole game.
> ## __Game Modes:__
> > This program simulates the game without various settings and records the results for analysis. The modes are controlled by the following toggles:
> > - `pm_takeoff_bump` 
> >   - if a player has all their planes over the prime meridian and gets bumped, they will draw a takeoff for the eastern hemisphere and move their plane there instead of sending it back to the start
> >   - `false ` by default
> > - `wilds`
> >   - enables wilds
> >   - `true ` by default
> > - `take-offs`
> >   - enables take-offs
> >   - `true ` by default

# `The Results`

My basic question when beginning this project was how different variations on the Takeoff rules would effect the overall course of the game. The main rule variation I considered was what I ended up calling the `pm_takeoff_bump`, a subject of much debate in my family. I also added implimented the ability to turn off wilds or take-offs to see how simplifying the game and removing fundemental tools changes the overall experience. As for measurements, they are still rather rudementary, focussing on counting the biggest events in the game in their simplest form: how many turns it takes a player to finish, how often people get bumped. While this data is tracked by individual players or planes, I have not parsed out some of the more complicated relationships. As it stands, I have focussed on building a robust simulation system upon which further features and analysis can be built.

However, even with the relatively limited data I have collected, some conclusions can be drawn.

## Conclusion #1: _Our (probably) arguments didn't matter_
> As I have said, the most often debated house rule in my family is the more lenient version of bumping for a player who has all of their planes over the prime meridian. However, reviewing the table, there seems to be little effect from this rule. In a large map, closer to the real map size, these special bumps very rarely happen. Even in a smaller map where it is more viable to bump players who have all their planes in the western hemisphere, there is no clear trend in the variations of data between scenarios with and without the special rule.
> 
> Given, this rule is likely a little less effective because computer players do not strategize like human players might. They do not (currently) prioritize getting all their planes past the prime meridian mark or chasing down players who have done so. Perhaps keener strategies would incrase the prevalance of altered bumps.
> 
> Additionally, the effect of the altered bump rule might be less about overall game length and more about how a player feels when getting a plane bumped back to the start when they were almost at the end, the random placement makes the experience feel less punishing. This is the sort of reasoning that would be difficult to measure with a computer simulation

## Conclusion #2: _Less tools means longer games:_
> One clear conclusion that can be drawn from the data I've gathered is that removing wilds from the game singificantly increases its length. The time it took for the winners and losers to finish jumped by about 20-30 turns compared to the wildless simulations' wilder counterparts. This makes a lot of sense, because wilds allow players to get out of a tough space more easily, but the difference is definitely worth noting.

## Conclusion #3: _Take-offs make you safer:_
> Surprisingly, the setting with the biggest effect on take-offs was not the setting that was built around an extra take-off or the one that gave players more flexibility to get a bump, but the one that randomly jumped you around the board. To be more specific, On larger boards, game's without take-offs had significantly more bumps than those with take-offs. Even taking into account the difference in game length. On smaller boards, there isn't really a difference, but on the large board, the difference is significant. While, in scenarios without takeoffs, the average rounds per bump was __1.8__, in scenarios `without` takeoffs that number was __3.3__. The effect is especially pronounced in the scenarios with take-offs but no wilds, where a bump only occured every 4.8 rounds (thats 19 turns taken by players).
>
> In hindsight, this shouldn't have been too surprising. Take-offs have the potential to spread out player's planes significantly, lessening opportunities for bumps, if you also remove the flexibility that wilds provide, bumps ought to be rather rare. This effect did not appear when I was testing with smaller maps because even a best-case difference take-off only progresses about 4 spaces, keeping the planes rather clumped
> | 239 Airports, 1x1 | Avg Total Turns | Avg Total Bumps | Rounds per Bump |
> |-:|:-:|:-:|:-:|
> | __Wilds, Takeoffs__ | 851 | 347 | `0.4` |
> | _(with altered bumps):_ | 867 | 248 | `3.5` | 
> |
> | __Wilds, No Takeoffs__ | 1079 | 639 | 1.7 |
> | _(with altered bumps):_ | 961 | 527 | 1.8 | 
> |
> | __No Wilds, Takeoffs__ | 760 | 143 | `5.3` |
> | _(with altered bumps):_ | 869 | 142 | `6.11` |
> |
> | __No Wilds, No Takeoffs__ | 1416 | 771 | 1.8 |
> | _(with altered bumps):_ | 1074 | 407 | 2.6 |
> |

# DATA:
## Big map, few simulations:
> | 239 Airports, 5x5 | Avg Winner Turns | Avg Loser Turns | Avg Total Turns |Avg Total Bumps | Avg Total Altered Bumps |
> |-:|:-:|:-:|:-:|:-:|:-:|
> | __Wilds, Takeoffs__ | 151.12 | 253.76 | 816.56 | 254.8 |  |
> | _(with altered bumps):_ | 138.2 | 260.92 | 828.6 | 251.92 | 1.88 | 
> |
> | __Wilds, No Takeoffs__ | 144.32 | 382.28 | 1108.16 | 617.88 |  |
> | _(with altered bumps):_ | 146.88 | 370.64 | 1084.24 | 631.4 | 0.36 | 
> |
> | __No Wilds, Takeoffs__ | 160.88 | 280.84 | 892.12 | 185.44 |  |
> | _(with altered bumps):_ | 157.56 | 280.76 | 897.2 | 190.96 | 3.2 | 
> |
> | __No Wilds, No Takeoffs__ | 184.64 | 411.72 | 1278.36 | 628.8 |  |
> | _(with altered bumps):_ | 191.6 | 428.6 | 1334.64 | 701.8 | 0.6 | 
> |

## Smaller map, many simulations:
> | 30 Airports, 10 maps, 2 runs per map | Avg Winner Turns | Avg Loser Turns | Avg Total Turns | Avg Total Bumps | Avg Total Altered Bumps |
> |-:|:-:|:-:|:-:|:-:|:-:|
> | __Wilds, Takeoffs__ | 45.9 | 96.5 | 296.85 | 214.6 |  |
> | _(with altered bumps):_ | 47.05 | 91.55 | 286.6 | 207.6 | 2.7 | 
> |
> | __Wilds, No Takeoffs__ | 50.45 | 108.1 | 340.75 | 321.1 |  |
> | _(with altered bumps):_ | 63.75 | 112.95 | 367.55 | 367.05 | 3.4 | 
> |
> | __No Wilds, Takeoffs__ | 71.85 | 128.1 | 405.45 | 256.55 |  |
> | _(with altered bumps):_ | 61 | 114.65 | 361.25 | 230.7 | 4.35 | 
> |
> | __No Wilds, No Takeoffs__ | 67.3 | 126.35 | 403.75 | 327.4 |  |
> | _(with altered bumps):_ | 61.3 | 122.65 | 393.55 | 326.8 | 3.75 | 
> |


# How to use it all:
> ## ___Running main.cpp:___
> > My main.cpp file is designed to run each scenario any number of times on any number of map. It goes something like this:
> > - The user is prompted to input how many maps should be simulated and how many simulations to do for each "scenario" on each map. 
> > - The code then generates every "scenario", or combination of game settings (it uses the same permutation algorithm as the move simulation process). There currently 3 boolean toggles for a total of 8 scenarios
> > - For each map, the code creates a Game object
> > - Then, for each scenario, the code updates the Game's settings (but not its map) and run as many simulations on those settings as the user specified
> > - The code then pulls the results data from the game object, stores in in a master stucture, and repeats for each scenario
> > - Once all maps have been run, the code formats the data it collected into a table in the file "results.md" (the file is overwritten each time)
> > 
> > The following is a table produced by a run on 10 maps, 2 simulations per scenario per map, 30 airports per match it took about 12 minutes to run those simulations on my machine: 
> 
> `I HAVE SINCE INCREASED THE NUMBER OF AIRPORTS TO 238, EXPECT LONGER SIMULATION TIMES, DO 1x1`
> > | 30 Airports, 10x2 | Avg Winner Turns | Avg Loser Turns | Avg Total Turns | Avg Total Bumps | Avg Total Altered Bumps |
> > |-:|:-:|:-:|:-:|:-:|:-:|
> > | __Wilds, Takeoffs__ | 45.9 | 96.5 | 296.85 | 214.6 |  |
> > | _(with altered bumps):_ | 47.05 | 91.55 | 286.6 | 207.6 | 2.7 | 
> > |
> > | __Wilds, No Takeoffs__ | 50.45 | 108.1 | 340.75 | 321.1 |  |
> > | _(with altered bumps):_ | 63.75 | 112.95 | 367.55 | 367.05 | 3.4 | 
> > |
> > | __No Wilds, Takeoffs__ | 71.85 | 128.1 | 405.45 | 256.55 |  |
> > | _(with altered bumps):_ | 61 | 114.65 | 361.25 | 230.7 | 4.35 | 
> > |
> > | __No Wilds, No Takeoffs__ | 67.3 | 126.35 | 403.75 | 327.4 |  |
> > | _(with altered bumps):_ | 61.3 | 122.65 | 393.55 | 326.8 | 3.75 | 
> > |

> ## ___If you wanted to make your own tests:___
> > ### Here's the functions you need to know:
> > > ## __`Game::Game()`__
> > > > ### __What it does:__
> > > > - Initializes settings
> > > > - Generates map, the layout of the map will not change for the life of the object
> > > > ### __Arguments:__
> > > > > |Type|Name|Default|
> > > > > |:-|:-|:-|
> > > > > | __Game Size:__
> > > > > |(int)|players|= 4|
> > > > > |(int)|planes|= 4|
> > > > > | __Settings:__
> > > > > |(bool)|pm_takeoff_bump|= true|
> > > > > |(bool)|wilds|= true|
> > > > > |(bool)|takeoffs|= true|
> > > > > |(bool)|debug|= true|
> > > > > | __Leftover:__
> > > > > |(int)|max_turns|= 300|
> > > ## __`void Game::run_game()`__
> > > > ### __What it does:__
> > > > - Initializes Players, Planes, and Take-off decks
> > > > - runs the main game look, in which all the simulations occur
> > > ## __`vector<float> Game::get_games_data()`__
> > > > ### __What it does:__
> > > > - Collects and returns benchmarking data in a summarized form
> > > > - Clears things that are meant to be cleared between benchmarkings:
> > > >   - Players
> > > >   - Decks
> > > >   - Benchmarking data (after it's been summarized)
> > > > ### __Returns:__
> > > > > `vector\<float\> data`, which has the form...
> > > > > - Average turns for the winner to finish (how long a regular game would've taken)
> > > > > - Average turns for the loser to finish
> > > > > - Average total turns all players to finish
> > > > > - Average bumps per game
> > > > > - Average bumps per game that were altered by the `pm_takeoff_bump` rule (if it is enabled)
> > > ## __`void Game::update_settings()`__
> > > > ### __What it does:__
> > > > - updates game settings to allow different scenarios to be run on the same map
> > > > ### __Arguments:__
> > > > > |Type|Name|
> > > > > |:-|:-|
> > > > > |(bool)|pm_takeoff_bump|
> > > > > |(bool)|wilds|
> > > > > |(bool)|takeoffs|

## Referenced:
> "Print all possible strings of length k that can be formed from a set of n characters" from geeksforgeeks.com (https://www.geeksforgeeks.org/print-all-combinations-of-given-length/) when developing permutations algorithms
> 
> zneak's answer from "Template container iterators" on StackOverflow (https://stackoverflow.com/questions/30018517/template-container-iterators) when developing permutations algorithms
> 
> "Goto stament in C/C++" from geeksforgeeks.com (https://www.geeksforgeeks.org/goto-statement-in-c-cpp/) when developing my decision-making algorithm
> 
> John Dibling's answer to "C++ new operator scope" on StackOverflow (https://stackoverflow.com/questions/23508156/c-new-operator-scope) when troubleshooting memory scoping
> 
> kilojoules' answer to " “X does not name a type” error in C++ " (https://stackoverflow.com/questions/2133250/x-does-not-name-a-type-error-in-c/2133260) when troubleshooting compile errors
> 
> referenced Kerrek SB's answer to "Read file line by line using ifstream in C++" on Stack Overflow (https://stackoverflow.com/questions/7868936/read-file-line-by-line-using-ifstream-in-c) for his method of reading through a text file
>
> referenced David Rodriguez's answer to "How do I clear the std::queue efficiently?" on StackOverflow (https://stackoverflow.com/questions/709146/how-do-i-clear-the-stdqueue-efficiently) for his method of erasing queues
>
> General reference: http://www.cplusplus.com/reference/algorithm/, http://www.cplusplus.com/reference/vector/vector/, http://www.cplusplus.com/reference/map/map/, http://www.cplusplus.com/reference/cctype/tolower/, http://www.cplusplus.com/reference/queue/queue/, http://www.cplusplus.com/reference/set/set/set/, http://www.cplusplus.com/doc/tutorial/exceptions/e