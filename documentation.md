# What the program is meant to do:
> My family owns and enjoys a board game called "Take-off" in which players move a fleet of planes across a map of the world. However, whenever we play we get into an argument about how to play. We each want to impliment slightly more or less punishing rules to make the game a more managable length. My project attempts to put those arguments to rest by simulating many Take-off games (which are themselves a simulation of real planes) under different rule-sets and comparing the results

# What the program will need to do:
> To simulate a game the program will need
> - a `Game` object to store and handle the map (hash table), deck (queue), dice (function), and players (objects) as well and compiling the benchmarking data
> - `Airport` structures to populate the map as spaces, track the connections between spaces, and track the location of planes
> - `Player` objects to store and handle `Airplane` objects as gameplay pieces. On their turn, the `Game` will tell a `Player` which actions they are allowed to take and a player must consider all the possibilites, choose the best one, and send those directions to the planes
> - `Airplane` objects to serve as piece which should handle their movements. `Players` will send Airplanes `Actions` which the Airplane must parse and execute: locating their destination and updating the location-tracking of their current (soon to be former) `Airport`, their destination `Airport`, and their own internal locaion tracking
> - Additional utlity structures such as `Color` and `Action` to hold common groupings of data and/or data designated for a particular role
> 
> A Game will require:
> - Game setup
> - A main gameplay loop
> - Game ending
> 
> Game setup will require:
> - generating all `Players`, `Airplanes`, `Airports`, and connections between `Airports`, as well as initializing the map and deck(s)
> 
> Game ending will involve:
> - Variable cleanup(if necessary)
> - Outputting benchmark data
> 
> The main gameplay loop will involve:
> - Iterating through rounds
> - Iterating through `player's` turns
> - Rolling for `players` and sending them actions to use that turn
> - Keeping track of when `players` or the `game` are finished
> - Collecting benchmark data
> 
> Player's turns will involve
> - Simulating all possible movements with given `actions` and `airplanes`
> - Evaluating which set of movements is the best
> - Executing those movements by sending `actions` to the `airplanes`
> - Handling bumping other `player's` `airplanes`
> - Detecting when one or all of their `airplanes` have finished
> - Collecting benchmark data

# Notable Programming solutions

>There are a few parts of my program that deserve some additional explaination
>
>### The Map
> > The Take-off map is essentially a web of Airports connected by colored "routes." Each turn, the player will roll the dice to see which colors they can move on that turn and then move accordingly. You might roll green and a wild and decide to move one of your planes (the pieces) from Heathrow to JFK along a green, and another from Sydney to Dehli on red with the wild. I decided to store my Airport objects in a map, with the connections being stored in vectors of pairs of pointers and colors in each Airport (each airport knows where it's outgoing routes connect to and with what colors, as well as where it's incoming route connect to and with which colors).
> >
> > Currently, the map is generated by pulling Airport data from "map.txt" and automatically generating connections between nearby airport, enforcing continuous east-to-west motion. The map is initialized with the game object and the Airports and connections remain the same for the entire life of that game object
> > 
> > > __DISCLAIMER:__ What follows is a long and probably unconvincing explaination as to why I used a hash table to store my Airports instead of doing it all with a custom web/tree structure. Read it at your own risk
> >
> > > _The game's map is a `hash table` (std::unorderer_map) of Airports keyed with strings stored in the Game object. While the map hash a tree-like structure with its Airport nodes and connection branches, a tree was not used for two reasons, one of which is actually good. My initial reason was "Take-off" card. Players will often roll a "Take-off" action which will jump one of their plane's to a random location on the map (drawn from the deck). In game, this involves searching the map for the Airport on the card, and searching a "tree" where nodes have multiple parents would be a nightmare. Meanwhile, hash tables are designed for direct access via a key: the name on the card. Simply put the names of the airport on the "card" and use that as the hash table key. Admittedly, because this is a program and not real life, I could I have put a point to the airport "on the card" instead of its name, so this wasn't really a problem at all. My second, better although not perfect reason was that a stl hash table is much more reliable than a a custom tree I made. Additionally, I reasoned, the main downside of a hash table is its size, but my map was going to be limited to, at most, about 100 items which is small in the grand computer science scal of things. I decided to use the stable, stl hash table as my base container, with connections stored in both the child and parent Airport_
> 
>
> ### Player AI
> > Each turn, players essentially receive a list of possible actions from whatever they rolled. Normally, that's a list of 2, one for each dice, although doubles take that number to 4. Combined with their (by defualt) 4 planes, that is quite a lot of possible turns, especially when one factors in wilds.
> >
> > In my simulation, computer players decide how to use their rolls like so:
> > - First, use any Take-off! actions your rolled and use them on your worst planes. You've gotta use them first by the rules (or at least it's more fun that way), and it's (almost) always best to use your worst plane for it.
> > - Next, get all the possible orders you could use the remaining moves and the ways you could apply them to your planes. (For two moves A and B and two planes 1 and 2, that's AB and BA and 11, 12, 21, and 22).
> > - For each permutation of planes, for each permutation of actions applied to those planes, play out those moves on a "shadow board" and pick the best one
> > - The "best" series of movements must use as many actions as possible and avoid illegal moves. After that, the computer will prioritize advancing their planes and bumping other players.
> > - Finally, do all those actions you decided on for real
>
> ### Simulations
> > Every turn, a player will need to consider many possible sequences of movements. The only way to effectively determine which moves are legal and which are best is to simulate what you would happen if you took those actions on those planes. In order to account for all the events possible in a turn, such simulations effectively require a copy of the entire board where the actions can be performed and analyzed without effecting the main gamestate. We will call this the "shadow board". In order to avoid creating a copy of all Aiports and Airplanes every time it wants to simulate a move, the program instead gives each Airport an "occupancy" and a "shadow occupancy" and each Airplane has a "location" and a "shadow location." Before each simulation, the shadow occupancies and locations are synced to their main-board counterparts. To preform a simulation, the program uses all the same movement functions, but it sends each one a flag saying "this is happening on the shadow board." That's how the program simulates turns without effecting the real board or having to copy a bunch of stuff. This is especially important because the simulations are the most time-consuming part of the whole game.

# `A detailed report and analysis of your findings.`

# How to use it all:
> ## ___Running main.cpp:___
> > My main.cpp file is designed to run each scenario any number of times on any number of map. It goes something like this:
> > - The user is prompted to input how many maps should be simulated and how many simulations to do for each "scenario" on each map. 
> > - The code then generates every "scenario", or combination of game settings (it uses the same permutation algorithm as the move simulation process). There currenlt 3 boolean toggles for a total of 8 scenarios
> > - For each map, the code creates a Game object
> > - Then, for each scenario, the code updates the Game's settings (but not its map) and run as many simulations on those settings as the user specified
> > - The code then pulls the results data from the game object, stores in in a master stucture, and repeats for each scenario
> > - Once all maps have been run, the code formats the data it collected into a table in the file "results.md" (the file is overwritten each time)
> > 
> > The following is a table produced by a run on 10 maps, 2 simulations per scenario per map, it took about 12 minutes to run those simulations on my machine:
> > | 10x2 | Avg Winner Turns | Avg Loser Turns | Avg Total Turns | Avg Total Bumps | Avg Total Altered Bumps |
> > |-:|:-:|:-:|:-:|:-:|:-:|
> > | __Wilds, Takeoffs__ | 45.9 | 96.5 | 296.85 | 214.6 |  |
> > | _(with altered bumps):_ | 47.05 | 91.55 | 286.6 | 207.6 | 2.7 | 
> > |
> > | __Wilds, No Takeoffs__ | 50.45 | 108.1 | 340.75 | 321.1 |  |
> > | _(with altered bumps):_ | 63.75 | 112.95 | 367.55 | 367.05 | 3.4 | 
> > |
> > | __No Wilds, Takeoffs__ | 71.85 | 128.1 | 405.45 | 256.55 |  |
> > | _(with altered bumps):_ | 61 | 114.65 | 361.25 | 230.7 | 4.35 | 
> > |
> > | __No Wilds, No Takeoffs__ | 67.3 | 126.35 | 403.75 | 327.4 |  |
> > | _(with altered bumps):_ | 61.3 | 122.65 | 393.55 | 326.8 | 3.75 | 
> > |

> ## ___If you wanted to make your own tests:___
> > ### Here's the functions you need to know:
> > > ## __`Game::Game()`__
> > > > ### __What it does:__
> > > > - Initializes settings
> > > > - Generates map, the layout of the map will not change for the life of the object
> > > > ### __Arguments:__
> > > > > |Type|Name|Default|
> > > > > |:-|:-|:-|
> > > > > | __Game Size:__
> > > > > |(int)|players|= 4|
> > > > > |(int)|planes|= 4|
> > > > > | __Settings:__
> > > > > |(bool)|pm_takeoff_bump|= true|
> > > > > |(bool)|wilds|= true|
> > > > > |(bool)|takeoffs|= true|
> > > > > |(bool)|debug|= true|
> > > > > | __Leftover:__
> > > > > |(int)|max_turns|= 300|
> > > ## __`void Game::run_game()`__
> > > > ### __What it does:__
> > > > - Initializes Players, Planes, and Take-off decks
> > > > - runs the main game look, in which all the simulations occur
> > > ## __`vector<float> Game::get_games_data()`__
> > > > ### __What it does:__
> > > > - Collects and returns benchmarking data in a summarized form
> > > > - Clears things that are meant to be cleared between benchmarkings:
> > > >   - Players
> > > >   - Decks
> 

## Referenced:
> "Print all possible strings of length k that can be formed from a set of n characters" from geeksforgeeks.com (https://www.geeksforgeeks.org/print-all-combinations-of-given-length/) when developing permutations algorithms
> 
> zneak's answer from "Template container iterators" on StackOverflow (https://stackoverflow.com/questions/30018517/template-container-iterators) when developing permutations algorithms
> 
> "Goto stament in C/C++" from geeksforgeeks.com (https://www.geeksforgeeks.org/goto-statement-in-c-cpp/) when developing my decision-making algorithm
> 
> John Dibling's answer to "C++ new operator scope" on StackOverflow (https://stackoverflow.com/questions/23508156/c-new-operator-scope) when troubleshooting memory scoping
> 
> kilojoules' answer to " “X does not name a type” error in C++ " (https://stackoverflow.com/questions/2133250/x-does-not-name-a-type-error-in-c/2133260) when troubleshooting compile errors
> 
> referenced Kerrek SB's answer to "Read file line by line using ifstream in C++" on Stack Overflow (https://stackoverflow.com/questions/7868936/read-file-line-by-line-using-ifstream-in-c) for his method of reading through a text file
>
> referenced David Rodriguez's answer to "How do I clear the std::queue efficiently?" on StackOverflow (https://stackoverflow.com/questions/709146/how-do-i-clear-the-stdqueue-efficiently) for his method of erasing queues
>
> General reference: http://www.cplusplus.com/reference/algorithm/, http://www.cplusplus.com/reference/vector/vector/, http://www.cplusplus.com/reference/map/map/, http://www.cplusplus.com/reference/cctype/tolower/, http://www.cplusplus.com/reference/queue/queue/, http://www.cplusplus.com/reference/set/set/set/, http://www.cplusplus.com/doc/tutorial/exceptions/